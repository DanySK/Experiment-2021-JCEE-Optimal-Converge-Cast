[![DOI](https://zenodo.org/badge/331352732.svg)](https://zenodo.org/badge/latestdoi/331352732)
![](https://github.com/DanySK/Experiment-2021-JCEE-Optimal-Converge-Cast/workflows/CI/badge.svg)

# Case study for Optimal Resilient Distributed Data Collection in Mobile Edge Environments

## Organization

This repository is organized as follows:
* `src/main` contains source files, split by languages
* Simulation descriptors are found in `src/main/yaml`
* Build source and executing simulation has been automated via Gradle.
The build and execution procedure is defined in the `build.gradle.kts` and `settings.gradle.kts` files
* `data` contains data generated by us when executing the experiments, it is tracked in order to ease further analyses and make them possible without re-running all the simulations.
* `effects` contains effect files compatible with the legacy Alchemist graphical interface that has been used to develop and debug the experiments.

## How to reproduce

### A note on performance

A premise to those willing to reproduce the experiment entirely:
you will need a well equipped machine (for 2020 standards, at least).
The time required to complete all such simulations may amount to *weeks*
for systems with low CPU parallelism.

We executed the experiments using the following hardware:

**Development Machine: Alienware Aurora R7**
* Intel Core i7 8700
* 32GB RAM
* Manjaro Linux 20.2 Nibia (using Linux 5.8.18-1-MANJARO x86_64 SMP PREEMPT)

**Batch-test Machine**
* 2x AMD EPYC 7301
* 128GB RAM
* Manjaro Linux 20.2 Nibia (using Linux 5.8.16-2-MANJARO x86_64 SMP PREEMPT)

#### Working with existing data

In order to speed up the work for those interested in reproducing the plot creation or acquiring further insights on the current experiments,
we track the whole data we ourselves generated when running the batch.
Processing such data and producing charts does not require any particularly powerful system and should complete in a matter of *minutes* on any modern
desktop hardware.

#### Requirements for executing and working with the simulations

1. A correct Java 11+ installation.
We recommend using one of the two versions which are under test
in our continuous integration system: AdoptOpenJDK Hotspot 11 and AdoptOpenJDK Hotspot 14; or the version in use by our Docker image: AdoptOpenJDK Hotspot 15.
Commands `java -version` and `javac -version` must work and print the correct version.

#### Requirements for data analysis and plotting

1. A correct Python 3 and Pip 3 installation. The experiments used version 3.9.1.
Commands `python --version` and `pip --version` must print the correct version 3.x.y, where x >= 8.

#### Executing simulations

To run the example you can rely on the pre-configured [Gradle](https://gradle.org) build script.
It will automatically download all the required libraries, set up the environment, and execute the simulator via command line for you.
As first step, use `git` to locally clone this repository.

Once done, you will be able to launch the simulations using the tasks named
`runAll<mode>` where `<mode>` can be `Batch` or `Graphic`, the former will start an headless run of all simulations, while the second will launch a single simulation with default values and pop up the graphical interface.

The selected tasks can be launched via Gradle as follows

on UNIX:
```bash
./gradlew runAll<mode>
```
On Windows:
```
gradlew.bat runAll<mode>
```

If you decide to use the graphical interface, press <kb>P</kb> to start the simulation.
For further information about the gui, see the [graphical interface shortcuts](https://alchemistsimulator.github.io/wiki/usage/gui/).

## License

Released under the terms of the GNU General Public License 3.0
